#include <string.h>
#include <stdlib.h>
#include "km.h"
#include "km_test_comm.h"
#include "km_test_dbg.h"

#if (CONFIG_AES_SUPPORT || CONFIG_HMAC_SUPPORT)
static uint8_t aes_key[32] = {
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
    0x38, 0x39, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
    0x38, 0x39, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66
};
uint32_t aes_test_key_len = 32;

static uint8_t hmac_test_key[16] = {
   0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
   0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01
};

uint32_t hmac_test_key_len = 16;
#endif

#if CONFIG_RSA_SUPPORT
static unsigned char n[128] = {//modulus
        0xe3, 0x9c, 0xd9, 0x8f, 0x36, 0xd0, 0x42, 0x44, 0xc7, 0xed, 0x84, 0x7c, 0x9a, 0x00, 0xf7, 0xc7,
        0x64, 0xdb, 0x86, 0x53, 0x8c, 0xb5, 0x1f, 0xf2, 0xd8, 0xc1, 0x96, 0x19, 0x84, 0x71, 0xbc, 0x38,
        0x44, 0xdb, 0x8b, 0xea, 0x3e, 0xee, 0xf4, 0xf4, 0x38, 0x14, 0x12, 0xaf, 0x45, 0x19, 0xe7, 0x64,
        0x52, 0x90, 0xa8, 0x5e, 0xc8, 0x80, 0xdb, 0x2b, 0x5b, 0x60, 0xa7, 0x89, 0x91, 0xa9, 0xc8, 0x7d,
        0xac, 0x9d, 0xf0, 0x37, 0xd7, 0xbc, 0xce, 0x0b, 0xb6, 0xf3, 0x10, 0x71, 0x71, 0xbb, 0x40, 0x37,
        0x5c, 0xea, 0xdd, 0xc5, 0x14, 0x30, 0x1d, 0xd3, 0xdb, 0x1c, 0x0c, 0xa2, 0xb4, 0xbe, 0x6d, 0x99,
        0xba, 0xae, 0x17, 0x6a, 0x55, 0x0b, 0x1a, 0x06, 0xc7, 0xdd, 0x91, 0x5a, 0x91, 0xae, 0x4e, 0xec,
        0x71, 0x20, 0x89, 0xf9, 0x81, 0xd2, 0x49, 0x00, 0x86, 0x94, 0x42, 0x12, 0x15, 0xe2, 0x4f, 0x39
    };

static unsigned char e[128] = {//pub
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01
    };

    static unsigned char d[128] = {//private
        0xd8, 0xb5, 0x14, 0x9a, 0x7b, 0x28, 0xab, 0x7f, 0x8b, 0x0e, 0x84, 0x0e, 0x92, 0x1e, 0x0b, 0xcb,
        0x27, 0x26, 0xaf, 0x6c, 0xca, 0xd2, 0x04, 0x3a, 0x15, 0xcf, 0xb2, 0x96, 0x56, 0xf8, 0x66, 0xa8,
        0xf8, 0x3e, 0x43, 0xa7, 0x62, 0x05, 0xe6, 0xe8, 0xc2, 0x9f, 0xb1, 0xee, 0x78, 0x0f, 0x22, 0xb4,
        0xec, 0xbb, 0x57, 0xe2, 0xee, 0x69, 0x68, 0xc2, 0x8d, 0xfc, 0xa7, 0x66, 0x9e, 0x6e, 0x15, 0x38,
        0x6e, 0x50, 0xe1, 0xc3, 0x38, 0xd9, 0x98, 0x0e, 0x2d, 0x9a, 0x22, 0x17, 0xcf, 0x98, 0xed, 0x28,
        0x5b, 0xa4, 0xfd, 0xad, 0x6c, 0x83, 0x3e, 0x73, 0xe0, 0x1b, 0xd0, 0xe6, 0x08, 0xac, 0x46, 0x7e,
        0xe8, 0x4f, 0x09, 0x2f, 0x80, 0x63, 0xab, 0xe1, 0x4b, 0x1a, 0x90, 0xa6, 0x0e, 0x64, 0xa9, 0x77,
        0x27, 0x20, 0x8c, 0x33, 0x27, 0x73, 0xf2, 0x10, 0x58, 0xc9, 0xea, 0x8d, 0xfa, 0x92, 0xa5, 0x51
    };

#if 0
    static unsigned char p[64] = {
        0xfc, 0x38, 0x64, 0x58, 0xdb, 0x1b, 0x3b, 0x25, 0x76, 0x29, 0x55, 0x84, 0xb3, 0xd7, 0x8d, 0x66,
        0x91, 0xbe, 0x10, 0xb8, 0xce, 0x5a, 0x61, 0xba, 0x92, 0x76, 0xfd, 0x50, 0xd9, 0xb2, 0x97, 0xb3,
        0x02, 0x5f, 0x66, 0x30, 0x09, 0x74, 0x50, 0xf7, 0x57, 0xf3, 0x5d, 0x69, 0x30, 0xbf, 0x4b, 0xe0,
        0xc1, 0x5b, 0x30, 0x4b, 0xb9, 0x7c, 0x2d, 0x28, 0x2b, 0x9f, 0x80, 0x59, 0xa5, 0x70, 0x4e, 0x55

    };

    static unsigned char q[64] = {
        0xe7, 0x06, 0x0d, 0xe5, 0x34, 0x40, 0xc7, 0x1b, 0xa5, 0xd7, 0x83, 0x39, 0xd5, 0x7b, 0x3d, 0x35,
        0x72, 0x8f, 0xe7, 0xec, 0x65, 0xcd, 0x06, 0x55, 0x69, 0x5a, 0x6e, 0x3a, 0xc3, 0x51, 0x95, 0xfd,
        0xe5, 0xb2, 0x4c, 0x0f, 0x43, 0x5d, 0xc9, 0xe9, 0xf0, 0x20, 0x71, 0x42, 0x9c, 0xf7, 0x66, 0x05,
        0x7c, 0x22, 0x80, 0x8d, 0xc0, 0xf4, 0x80, 0x80, 0x47, 0x1f, 0x4b, 0xfd, 0xfe, 0x2a, 0x19, 0x55
    };

    static unsigned char dmp1[64] = {
        0x70, 0xa2, 0x72, 0x55, 0xa8, 0x0b, 0x82, 0x1f, 0x59, 0xa4, 0x5d, 0xd7, 0x74, 0x44, 0xd7, 0x95,
        0xad, 0x92, 0x36, 0x7f, 0x81, 0x4f, 0xa5, 0x83, 0x1f, 0x33, 0x5a, 0x2e, 0xc7, 0xf9, 0x54, 0x7b,
        0x91, 0x9c, 0xae, 0xd2, 0xd6, 0xf6, 0x05, 0xce, 0x5f, 0x8d, 0x83, 0xf2, 0x9c, 0xdd, 0x60, 0xf2,
        0x4f, 0x06, 0xfd, 0x0b, 0x64, 0x1b, 0x0b, 0x43, 0x7c, 0x2f, 0xaf, 0xae, 0xd9, 0x0d, 0xcd, 0x3d
    };

    static unsigned char dmq1[64] = {
        0xe2, 0x80, 0x3f, 0x13, 0x5f, 0x5d, 0xbb, 0x58, 0xd2, 0x0a, 0x2f, 0xf0, 0x7d, 0xeb, 0xac, 0x21,
        0x40, 0xc6, 0xf2, 0x7e, 0x05, 0x79, 0x34, 0x22, 0x7d, 0x7e, 0x59, 0xe0, 0x67, 0x2b, 0x10, 0x41,
        0xb3, 0xf8, 0x51, 0x36, 0x0d, 0xb8, 0x60, 0x84, 0x6a, 0x17, 0x84, 0xb3, 0xe8, 0xad, 0x6e, 0x6b,
        0x26, 0x3f, 0xb5, 0x86, 0x45, 0x8d, 0xf2, 0x86, 0xd2, 0x34, 0x4f, 0x0f, 0x21, 0x28, 0x29, 0x59
    };

   static unsigned char iqmp[64] = {
        0x25, 0xd2, 0x40, 0x23, 0xc5, 0x12, 0xd4, 0xc9, 0x94, 0xcc, 0x85, 0xa6, 0x79, 0xa4, 0x4a, 0x22,
        0xb0, 0x84, 0x9a, 0x5a, 0x78, 0x0a, 0xec, 0x2d, 0xcf, 0x55, 0xb4, 0x33, 0x53, 0x2d, 0xb0, 0xe1,
        0x7a, 0x5f, 0x7b, 0x19, 0xef, 0x5c, 0x3d, 0x87, 0x7e, 0xbf, 0x6c, 0x37, 0x83, 0x37, 0x3f, 0xaa,
        0x0e, 0xf2, 0x41, 0xa7, 0x84, 0x45, 0x29, 0x7e, 0x70, 0x6f, 0x24, 0x2c, 0x38, 0xc8, 0x9a, 0xd2
    };
#endif
#endif /* CONFIG_RSA_SUPPORT */

#ifdef CONFIG_RSA_SUPPORT
static void gen_rsa_data(km_key_data_t *key_data)
{
    km_rsa_key_t *rsa = &(key_data->rsa_key);
    memset(rsa, 0, sizeof(km_rsa_key_t));

    rsa->n_len = 128;
    rsa->e_len = 128;
    rsa->d_len = 128;

    rsa->n = km_malloc(128);
    rsa->e = km_malloc(128);
    rsa->d = km_malloc(128);
    if (!rsa->n || !rsa->e || !rsa->d) {
        KM_TEST_ERR("malloc failed\n");
        return;
    }

    memcpy(rsa->n, n, 128);
    memcpy(rsa->e, e, 128);
    memcpy(rsa->d, d, 128);

    key_data->type = KM_RSA;

    return;
}

static void clean_rsa_data(km_key_data_t *key_data)
{
    if (key_data) {
        km_rsa_key_t *key = &(key_data->rsa_key);
        if (key) {
            if (key->n) {
                km_free(key->n);
                key->n = NULL;
            }
            if (key->e) {
                km_free(key->e);
                key->e = NULL;
            }
            if (key->d) {
                km_free(key->d);
                key->d = NULL;
            }
        }
    }
    return;
}
#endif /* CONFIG_RSA_SUPPORT */

#if (CONFIG_AES_SUPPORT || CONFIG_HMAC_SUPPORT)
void gen_sym_key_data(km_key_data_t *key_data,
                         km_key_type key_type)
{
    uint32_t key_len = 0;
    km_sym_key_t *sym_key = &(key_data->sym_key);

    memset(key_data, 0, sizeof(km_key_data_t));

    if (key_type == KM_AES) {
        sym_key->key_bit = 256;
    } else if (key_type == KM_HMAC) {
        sym_key->key_bit = 128;
    }

    key_len = sym_key->key_bit >> 3;
    sym_key->key = km_malloc(key_len);
    if (!sym_key->key) {
        KM_TEST_ERR("malloc aes key failed\n");
        return;
    }

    if (key_type == KM_AES) {
        if (key_len > aes_test_key_len) {
            key_len = aes_test_key_len;
        }
        km_memcpy(sym_key->key, aes_key, key_len);
    } else if (key_type == KM_HMAC) {
        km_memcpy(sym_key->key, hmac_test_key, hmac_test_key_len);
    }

    key_data->type = key_type;
}

void clean_sym_data(km_key_data_t *key_data)
{
    if (key_data) {
        km_sym_key_t *sym_key = &(key_data->sym_key);
        if (sym_key) {
            if (sym_key->key) {
                km_free(sym_key->key);
                sym_key->key = NULL;
            }
        }
    }
}
#endif /* CONFIG_AES_HMAC_SUPPORT */

uint32_t test_import(char *name, uint32_t name_len, km_key_type type)
{
    km_key_data_t key_data;
    uint32_t ret = 0;

    switch(type) {
#if CONFIG_RSA_SUPPORT
        case KM_RSA: {
            gen_rsa_data(&key_data);
            break;
        }
#endif /* CONFIG_RSA_SUPPORT */
#if (CONFIG_AES_SUPPORT || CONFIG_HMAC_SUPPORT)
        case KM_AES:
        case KM_HMAC: {
            gen_sym_key_data(&key_data, type);
            break;
        }
#endif
        default: {
            return -1;
        }
    }
    ret = km_import_key(name, name_len, KM_KEY_FORMAT_RAW,
                     &key_data, sizeof(key_data));
    if (ret && ret != KM_ERR_ACCESS_CONFLICT) {
        KM_TEST_ERR("import failed 0x%x\n", ret);
        goto clean;
    }

clean:
    switch(type) {
#if CONFIG_RSA_SUPPORT
        case KM_RSA: {
            clean_rsa_data(&key_data);
            break;
        }
#endif /* CONFIG_RSA_SUPPORT */
#if (CONFIG_AES_SUPPORT || CONFIG_HMAC_SUPPORT)
        case KM_AES:
        case KM_HMAC: {
            clean_sym_data(&key_data);
            break;
        }
#endif
    }

    return ret;
}

uint32_t test_generate(char *name, uint32_t name_len,
                  km_key_type type, uint32_t key_size)
{
    uint32_t ret = 0;

    switch(type) {
#if CONFIG_RSA_SUPPORT
        case KM_RSA: {
            km_rsa_gen_param rsa_param;
            rsa_param.key_size = key_size;
            rsa_param.exponent = 0x10001;
            ret = km_generate_key(name, name_len, type, &rsa_param);
            break;
        }
#endif /* CONFIG_RSA_SUPPORT */
#if (CONFIG_AES_SUPPORT || CONFIG_HMAC_SUPPORT)
        case KM_AES:
        case KM_HMAC: {
            km_sym_gen_param sym_param;
            sym_param.key_size = key_size;
            ret = km_generate_key(name, name_len, type, &sym_param);
            break;
        }
#endif
        default: {
            ret = KM_ERR_GENERIC;
            break;
        }
    }

    if (ret && ret != KM_ERR_ACCESS_CONFLICT) {
        KM_TEST_ERR("generate key failed 0x%x\n", ret);
    }

    return ret;
}

uint32_t test_delete(char *name, uint32_t name_len)
{
    uint32_t ret = 0;

    ret = km_delete_key(name, name_len);
    if (ret && ret != KM_ERR_ITEM_NOT_FOUND) {
        KM_TEST_ERR("delete key failed ret 0x%x\n", ret);
        return ret;
    }

    return ret;
}

#if KM_TEST_DEBUG
void km_test_dump_data(char *name, uint8_t *data, uint32_t len)
{
    uint32_t i;
    printf("name is %s, len is %d\n", name, len);

    for (i = 0; i < (len - len % 8); i += 8) {
        printf("%s:  %02x %02x %02x %02x %02x %02x %02x %02x\n",
                          name, data[i+0], data[i+1], data[i+2], data[i+3],
                          data[i+4], data[i+5], data[i+6], data[i+7]);
    }

    printf("%s:", name);
    while(i < len) {
        printf("%02x; ", data[i++]);
    }
    printf("\n");

    return;
}
#endif

